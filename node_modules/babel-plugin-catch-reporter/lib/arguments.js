"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getArgs=getArgs;var types=_interopRequireWildcard(require("@babel/types")),_constants=require("./constants");function _getRequireWildcardCache(){if("function"!=typeof WeakMap)return null;var cache=new WeakMap;return _getRequireWildcardCache=function(){return cache},cache}function _interopRequireWildcard(obj){if(obj&&obj.__esModule)return obj;if(null===obj||"object"!=typeof obj&&"function"!=typeof obj)return{default:obj};var cache=_getRequireWildcardCache();if(cache&&cache.has(obj))return cache.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj)if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}return newObj.default=obj,cache&&cache.set(obj,newObj),newObj}function getSceneInfo(knownData){const sceneInfo=`[${knownData.source}:${knownData.line}:${knownData.column}]`;return types.stringLiteral(sceneInfo)}function getFunctionArguments(path){const _path$node=path.node,_path$node2=void 0===_path$node?{}:_path$node,_path$node2$params=_path$node2.params,params=void 0===_path$node2$params?[]:_path$node2$params;return params.filter(param=>types.isIdentifier(param)).map(param=>param.name)}function getFunction(path,_,knownData){const argumentsToAdd=[],isCatchClause=types.isCatchClause(path);isCatchClause?(!path.node.param&&(path.node.param=types.identifier("e")),argumentsToAdd.push(path.node.param.name)):knownData.name===_constants.MEMBER_EXPRESSION_CATCH&&argumentsToAdd.push(...getFunctionArguments(path));const identifierArgs=argumentsToAdd.map(identifierName=>types.identifier(identifierName));return identifierArgs}function getArgs(path,state,knownData){// ignore for now:
// const sceneInfo = getSceneInfo(knownData)
const fnArgs=getFunction(path,state,knownData);return[...fnArgs]}