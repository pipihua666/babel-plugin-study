"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Program=Program,exports.CatchClause=CatchClause,exports.CallExpression=CallExpression;var types=_interopRequireWildcard(require("@babel/types")),_utils=require("./utils"),_template=require("./template"),_constants=require("./constants");function _getRequireWildcardCache(){if("function"!=typeof WeakMap)return null;var cache=new WeakMap;return _getRequireWildcardCache=function(){return cache},cache}function _interopRequireWildcard(obj){if(obj&&obj.__esModule)return obj;if(null===obj||"object"!=typeof obj&&"function"!=typeof obj)return{default:obj};var cache=_getRequireWildcardCache();if(cache&&cache.has(obj))return cache.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj)if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}return newObj.default=obj,cache&&cache.set(obj,newObj),newObj}const expressionCache=new Set;function Program(path,state){if(state.caught){const validPathAndState=(0,_utils.isValidPathAndState)(path,state);if(validPathAndState){const loggerName=(0,_utils.getLoggerName)(state),isDefaultLoggerName=loggerName===_constants.LOGGER_API,loggerWasImported=!!path.scope.bindings[loggerName];isDefaultLoggerName||loggerWasImported||path.unshiftContainer("body",types.importDeclaration([state.babelPluginLoggerSettings.namespaced?types.importNamespaceSpecifier(types.identifier(loggerName)):types.ImportDefaultSpecifier(types.identifier(loggerName))],types.stringLiteral((0,_utils.getLoggerSource)(state))))}}}function CatchClause(path,state){const validPathAndState=(0,_utils.isValidPathAndState)(path,state);validPathAndState&&(0,_utils.addLogger)(path,state)}function getCalleeName(callee){return callee?callee.computed?callee.property.value:(callee.property||{}).name:void 0}function findOutmostCallExp(path){let depth=0;const p=path.findParent(p=>(depth++,types.isCallExpression(p)||2<depth));return 2==depth&&null!==p&&void 0!==p&&p.isCallExpression()?findOutmostCallExp(p):path}function CallExpression(path,state){if(path.node.loc&&state.babelPluginLoggerSettings.catchPromise){let methodName=getCalleeName(path.node.callee);if("then"===methodName||"catch"===methodName){state.caught=!0;const callExpressionOutermost=findOutmostCallExp(path);if(expressionCache.has(callExpressionOutermost.node))return;const outermostName=getCalleeName(callExpressionOutermost.node.callee);if("catch"===outermostName){const catchFn=callExpressionOutermost.node.arguments[0];if(!catchFn)return;let argName;catchFn.params.length?argName=types.identifier(catchFn.params[0].name):(argName=path.scope.generateUidIdentifier("e"),catchFn.params.push(argName));let fnBody=catchFn.body.body;fnBody||(callExpressionOutermost.get("arguments.0.body").replaceWith((0,_template.returnStatement)({STATEMENT:catchFn.body})),fnBody=catchFn.body.body),callExpressionOutermost.get("arguments.0.body").replaceWith((0,_template.promiseCatchEnhancer)({BODY:fnBody,ARGUMENTS:argName,HANDLER:types.memberExpression(types.identifier(state.babelPluginLoggerSettings.name),types.identifier(state.babelPluginLoggerSettings.methodName))})),expressionCache.add(callExpressionOutermost.node)}else{const errorVariableName=path.scope.generateUidIdentifier("e");callExpressionOutermost.replaceWith((0,_template.promiseCatchStatement)({BODY:callExpressionOutermost.node,ERR:errorVariableName,HANDLER:types.memberExpression(types.identifier(state.babelPluginLoggerSettings.name),types.identifier(state.babelPluginLoggerSettings.methodName))})),expressionCache.add(callExpressionOutermost.node)}}}}